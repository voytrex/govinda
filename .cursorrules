# Govinda ERP - AI Coding Rules

## Project Context

Govinda is a modular monolith ERP for Swiss health insurance (KVG/VVG).

**Stack:** Java 21, Spring Boot 3.2+, PostgreSQL 18+, Maven, Testcontainers
**Architecture:** Domain-Driven Design with layered architecture
**Languages:** DE (primary), FR, IT, EN

---

## TDD Workflow - MANDATORY

**Every code change MUST follow Red-Green-Refactor. NO EXCEPTIONS.**

### The Cycle

```
1. RED     → Write failing test FIRST
2. GREEN   → Write MINIMAL code to pass
3. REFACTOR → Clean up, keep tests green
4. REPEAT
```

### Rules

1. **NEVER write production code without a failing test**
2. **Verify the test fails before implementing** (proves test validity)
3. **Write ONLY the code needed to pass the current test**
4. **Run tests after each phase to confirm state**

### Workflow Example

```java
// STEP 1: Write failing test (RED)
@Test
void should_calculateAge_when_birthDateProvided() {
    var person = new Person("Hans", LocalDate.of(1990, 6, 15));
    assertThat(person.ageAt(LocalDate.of(2025, 6, 15))).isEqualTo(35);
}
// Run test → FAILS (method doesn't exist)

// STEP 2: Minimal implementation (GREEN)
public int ageAt(LocalDate date) {
    return Period.between(birthDate, date).getYears();
}
// Run test → PASSES

// STEP 3: Refactor if needed, run tests → still PASSES
```

### Test Commands

```bash
# Single test
./mvnw test -pl backend/govinda-{module} -Dtest={TestClass}#{method}

# Module tests
./mvnw test -pl backend/govinda-{module}

# All tests
./mvnw test
```

---

## Internationalization (i18n) - CRITICAL

**ALL user-facing text MUST be internationalized. NO EXCEPTIONS.**

### Rules

| Do | Don't |
|----|-------|
| Use `LocalizedText` for content | Hardcode translations in enums |
| Use `MessageSource` for errors | Put `nameDe`, `nameFr` in enums |
| Use error codes in exceptions | Hardcode error messages |
| Respect `Accept-Language` header | Assume German only |

### Correct Patterns

```java
// Domain model with LocalizedText
public class Product {
    private LocalizedText name;        // All 4 languages
    private LocalizedText description;
}

// Enum with code only (translate in API layer)
public enum Canton {
    ZH, BE, AG, ZG;  // NO translations here
}

// Translation in API via MessageSource
String name = messageSource.getMessage("canton." + canton.name(), null, locale);

// Exception with error code
throw new EntityNotFoundException("error.person.not.found", personId);
```

### Wrong Patterns

```java
// BAD: Hardcoded translations in enum
public enum Canton {
    ZH("ZH", "Zürich", "Zurich");  // WRONG!
    private String nameDe, nameFr;
}

// BAD: Hardcoded error message
throw new RuntimeException("Person not found");  // WRONG!
```

### Message Files Location

```
backend/govinda-common/src/main/resources/
├── messages.properties      # English fallback
├── messages_de.properties   # German (primary)
├── messages_fr.properties   # French
└── messages_it.properties   # Italian
```

---

## Architecture

### Layer Dependencies

```
API → Application → Domain ← Infrastructure
```

- **Domain has ZERO external dependencies** (no Spring, no JPA annotations)
- Infrastructure implements domain ports

## Null-Safety (Nullness) - CRITICAL

We use Eclipse null analysis with **package-level defaults** and treat **nulls as exceptional** in our own code.

### Defaults

- Use `@NonNullApi` and `@NonNullFields` in package-level `package-info.java` for:
  - `domain.*`
  - `application.*`
  - `api.*`
  - `infrastructure.*` and `repository.*` where reasonable
- This means:
  - Method **parameters and return values** are non-null by default.
  - **Fields** are non-null by default.
  - `@Nullable` opt-out is required wherever `null` is a legitimate value.

### Domain & Entity Rules

- **Required fields** (IDs, mandatory relationships, timestamps, required value objects):
  - Must be marked non-null in persistence:
    - `@Column(nullable = false)`
    - `@ManyToOne(optional = false)` / `@JoinColumn(nullable = false)`
  - Must be initialized via **constructors or factory methods**.
  - Getters should **enforce the non-null contract**:
    ```java
    public Tenant getTenant() {
        return Objects.requireNonNull(tenant, "tenant");
    }
    ```
- **Optional fields** (e.g. last login, optional metadata):
  - Must be explicitly annotated with `@Nullable` on both field and accessor:
    ```java
    @Nullable
    private Instant lastLoginAt;

    @Nullable
    public Instant getLastLoginAt() { ... }
    ```

### Suppressions

- Suppress nullness warnings **only at boundaries** (framework integration), never across core domain logic:
  - Example: Spring APIs or JPA callbacks that aren't properly annotated.
- When you must suppress:
  - Use the **narrowest possible scope** (`@SuppressWarnings("null")` on a single method).
  - Add a **short comment** explaining why it is safe.

### Refactoring Guidelines

- New code:
  - Must be written null-safe from the start and compile **without nullness warnings**.
- Existing code:
  - When you touch a file in `domain.*`, **clean up its nullness warnings as part of the change**.
  - Prefer strengthening invariants (constructor initialization + non-null getters) over weakening them.
- For more details and patterns, see `docs/development/nullness-guidelines.md`.

### Package Structure

```
net.voytrex.govinda.{module}/
├── domain/
│   ├── model/          # Entities, Value Objects
│   ├── repository/     # Port interfaces
│   └── exception/      # Domain exceptions
├── application/        # Use cases, Commands, Services
├── infrastructure/
│   └── persistence/    # JPA adapters
└── api/                # Controllers, DTOs, Mappers
```

---

## Naming Conventions

### Classes

| Type | Pattern | Example |
|------|---------|---------|
| Entity | `{Name}` | `Person`, `Contract` |
| Value Object | `{Concept}` | `AhvNumber`, `Money` |
| Repository (Domain) | `{Entity}Repository` | `PersonRepository` |
| Repository (JPA) | `Jpa{Entity}RepositoryAdapter` | `JpaPersonRepositoryAdapter` |
| Service | `{Domain}Service` | `PersonService` |
| Controller | `{Domain}Controller` | `PersonController` |
| Request DTO | `{Action}{Entity}Request` | `CreatePersonRequest` |
| Response DTO | `{Entity}Response` | `PersonResponse` |
| Exception | `{Situation}Exception` | `EntityNotFoundException` |
| Test Class | `{ClassName}Test` | `PersonTest` |

### Methods

```java
// Business methods: verbs
calculatePremium(), findById(), create(), delete()

// Boolean: is, has, can, should
isActive(), hasPermission(), canDelete(), shouldNotify()

// Test: should_{behavior}_when_{condition}
should_calculateAge_when_birthDateProvided()
should_throwException_when_inputIsNull()
```

---

## Code Style

### Formatting

- **Line length:** 120 characters max
- **Indentation:** 4 spaces
- **Imports:** No wildcards, sorted

### Java 21+ Features to Use

```java
// Records for DTOs
public record CreatePersonRequest(String firstName, String lastName) {}

// Sealed classes for exception hierarchies
public sealed class DomainException permits EntityNotFoundException {}

// Pattern matching
if (entity instanceof Person person) { ... }

// Switch expressions
String label = switch (status) {
    case ACTIVE -> "Active";
    case INACTIVE -> "Inactive";
};
```

### Immutability

- Value objects: Always immutable (use records)
- Entities: Expose behavior, not setters
- DTOs: Use records

---

## Testing Standards

### Test Structure

```java
class PersonTest {

    @Nested
    @DisplayName("Age Calculation")
    class AgeCalculation {

        @Test
        @DisplayName("should calculate age correctly")
        void should_calculateAge_when_birthDateProvided() {
            // Arrange
            var person = PersonFixture.createDefault();

            // Act
            int age = person.ageAt(LocalDate.of(2025, 1, 1));

            // Assert
            assertThat(age).isEqualTo(35);
        }
    }
}
```

### Coverage Requirements

| Layer | Coverage |
|-------|----------|
| Domain (entities, value objects) | 100% |
| Application (services) | 80%+ |
| Infrastructure | Integration tests |
| API | Contract tests |

### Tools

- **JUnit 5** - Test framework
- **Mockito** - Mocking (@Mock, @InjectMocks)
- **AssertJ** - Fluent assertions (assertThat)
- **Testcontainers** - PostgreSQL for integration tests

---

## Exception Handling

### Pattern

```java
// Domain exception with error code
public final class EntityNotFoundException extends DomainException {
    public EntityNotFoundException(String errorCode, Object id) {
        super(errorCode, id);
    }
}

// Throwing
throw new EntityNotFoundException("error.person.not.found", personId);

// Testing
assertThatThrownBy(() -> service.findById(invalidId))
    .isInstanceOf(EntityNotFoundException.class)
    .hasFieldOrPropertyWithValue("errorCode", "error.person.not.found");
```

### Error Code Format

```properties
error.{domain}.{situation}
error.entity.not.found=Entity with ID {0} not found
error.person.ahv.duplicate=Person with AHV {0} already exists
error.validation.required={0} is required
```

---

## API Standards

### HTTP Methods & Status Codes

| Method | Purpose | Success Code |
|--------|---------|--------------|
| GET | Read | 200 |
| POST | Create | 201 |
| PUT | Replace | 200 |
| PATCH | Partial update | 200 |
| DELETE | Remove | 204 |

### Error Codes

| Code | When |
|------|------|
| 400 | Invalid request format |
| 401 | Not authenticated |
| 403 | Not authorized |
| 404 | Not found |
| 409 | Conflict/duplicate |
| 422 | Business rule violation |
| 500 | Server error |

---

## Definition of Done

Before considering ANY task complete:

```
[ ] Test written FIRST (TDD Red phase)
[ ] Test verified to fail before implementation
[ ] All tests pass: ./mvnw test
[ ] i18n: All user text in 4 languages
[ ] i18n: No hardcoded translations in enums
[ ] i18n: Error codes in MessageSource
[ ] Code follows naming conventions
[ ] No compiler warnings
[ ] Domain layer has no Spring/JPA imports
```

---

## Quick Reference

### Value Objects

```java
// Money
Money amount = Money.of(BigDecimal.valueOf(100), Currency.CHF);
Money rounded = amount.roundToRappen();

// AhvNumber
AhvNumber ahv = AhvNumber.of("756.1234.5678.97");

// LocalizedText
LocalizedText text = LocalizedText.builder()
    .de("German").fr("French").it("Italian").en("English")
    .build();
```

### Test Assertions (AssertJ)

```java
// Basic
assertThat(result).isNotNull();
assertThat(result).isEqualTo(expected);

// Collections
assertThat(list).hasSize(3);
assertThat(list).contains(item);
assertThat(list).isEmpty();

// Exceptions
assertThatThrownBy(() -> doSomething())
    .isInstanceOf(IllegalArgumentException.class)
    .hasMessageContaining("error");

// Optional
assertThat(optional).isPresent();
assertThat(optional).isEmpty();
```

---

---

## Docker & Colima Setup (macOS)

**For local testing with Testcontainers and docker-compose on macOS, use Colima.**

### Quick Setup

```bash
# Install (if not already installed)
brew install colima docker docker-compose

# Start Colima
colima start

# Verify
colima status
docker ps
```

### Environment Configuration

**Set DOCKER_HOST for Testcontainers:**

```bash
export DOCKER_HOST="unix://${HOME}/.colima/default/docker.sock"
```

**Add to `~/.zshrc` or `~/.bash_profile` for persistence:**

```bash
export DOCKER_HOST="unix://${HOME}/.colima/default/docker.sock"
```

### Running Tests

**The `scripts/test-local.sh` script automatically configures Docker for Colima:**

```bash
./scripts/test-local.sh                    # All tests
./scripts/test-local.sh --unit-only         # Unit tests only
./scripts/test-local.sh --integration-only  # Integration tests only
```

**Manual execution:**

```bash
export DOCKER_HOST="unix://${HOME}/.colima/default/docker.sock"
./mvnw test -pl backend/govinda-{module}
```

### Docker Compose

```bash
cd infrastructure/docker
docker-compose up -d                # Start PostgreSQL
docker-compose --profile full up -d # Start PostgreSQL + Redis
docker-compose down                 # Stop services
```

**Connection:**
- PostgreSQL: `localhost:5432` (user: `govinda`, password: `govinda`)

### Troubleshooting

- **Colima not running:** `colima start` or `colima restart`
- **Docker connection fails:** Verify `DOCKER_HOST` is set correctly
- **Testcontainers can't connect:** Ensure Colima is running and `DOCKER_HOST` is set

---

## Files to Reference

- [Definition of Done](docs/development/definition-of-done.md)
- [Coding Guidelines](docs/development/coding-guidelines.md)
- [Testing Strategy](docs/development/testing-strategy.md)
- [Testcontainers Setup](docs/development/testcontainers-setup.md)
- [CONTRIBUTING.md](CONTRIBUTING.md)
