# Govinda ERP - Cursor AI Coding Rules

## Internationalization (i18n) - CRITICAL

**ALL user-facing text MUST be internationalized. NO EXCEPTIONS.**

### Supported Languages
- DE (German) - Primary/fallback language
- FR (French)
- IT (Italian)
- EN (English)

### Rules

1. **Use `LocalizedText` for user-facing content**
   - Product names, descriptions, labels, UI text
   - Always provide all 4 language variants
   - Use `LocalizedText` from `net.voytrex.govinda.common.domain.model`

2. **NEVER hardcode translations in enums**
   - âŒ DO NOT add `nameDe`, `nameFr`, `nameIt`, `nameEn` fields to enums
   - âŒ DO NOT hardcode German/French/Italian text in enum constructors
   - âœ… Use enum codes and translate in API layer via MessageSource
   - âœ… Store translations in database or message properties files

3. **Error messages must be internationalized**
   - Use Spring `MessageSource` for error translation
   - Error codes should be language-agnostic (e.g., `ENTITY_NOT_FOUND`)
   - Translate based on `Accept-Language` header
   - No hardcoded English fallback messages

4. **API responses**
   - All user-facing strings must be localized
   - Respect `Accept-Language` header
   - Default to German (DE) if no language specified

5. **When creating or modifying code:**
   - If adding a new enum with display names â†’ use MessageSource, not enum fields
   - If adding error messages â†’ use MessageSource with error codes
   - If adding domain model fields â†’ use `LocalizedText` for multilingual content
   - If adding API response fields â†’ ensure they support i18n

### Examples

**âœ… CORRECT:**
```java
// Domain model with LocalizedText
public class Product {
    private LocalizedText name;  // âœ…
    private LocalizedText description;  // âœ…
}

// Enum with code only
public enum Status {
    ACTIVE("ACTIVE"),  // âœ… Code only
    INACTIVE("INACTIVE");
    // Translate in API layer using MessageSource
}
```

**âŒ WRONG:**
```java
// âŒ Hardcoded translations in enum
public enum Canton {
    ZH("ZH", "ZÃ¼rich", "Zurich"),  // âŒ
    BE("BE", "Bern", "Berne");     // âŒ
    private final String nameDe;
    private final String nameFr;
}

// âŒ Hardcoded error message
throw new Exception("Entity not found");  // âŒ
```

## Architecture

- Follow Domain-Driven Design (DDD)
- Layer dependencies: API â†’ Application â†’ Domain â† Infrastructure
- Domain layer has NO dependencies on other layers
- Use ports and adapters pattern

## Code Style

- Java 21+
- Maximum line length: 120 characters
- Use records for DTOs when appropriate
- Prefer immutability
- Meaningful names (no abbreviations)

## Test-Driven Development (TDD) - MANDATORY

**TDD is MANDATORY for ALL code changes. NO EXCEPTIONS.**

### The Red-Green-Refactor Cycle

**You MUST follow this cycle for EVERY feature, bug fix, or code change:**

1. **ðŸ”´ RED**: Write a failing test first
   - Test must fail for the right reason (not compilation errors)
   - Test should describe the desired behavior
   - Run the test to confirm it fails

2. **ðŸŸ¢ GREEN**: Write minimal code to make the test pass
   - Write ONLY the code necessary to pass the test
   - No premature optimization or extra features
   - Run the test to confirm it passes

3. **ðŸ”µ REFACTOR**: Improve code quality while keeping tests green
   - Clean up code, remove duplication
   - Improve naming, structure, and design
   - All tests must remain passing

### Strict Rules

1. **NEVER write production code without a failing test first**
   - âŒ DO NOT write implementation before tests
   - âŒ DO NOT write tests after implementation
   - âœ… ALWAYS write the test first, see it fail, then implement

2. **Test location and naming**
   - Unit tests: `src/test/java` mirroring `src/main/java` structure
   - Test class: `{ClassName}Test.java`
   - Test methods: `should_{expectedBehavior}_when_{condition}()` or `test_{featureName}()`

3. **Test requirements**
   - Write unit tests for ALL domain logic
   - Write integration tests for repositories and APIs
   - Use Testcontainers for database tests
   - Minimum 80% code coverage (enforced by CI)

4. **When modifying existing code:**
   - If adding new functionality â†’ write failing test first
   - If fixing a bug â†’ write failing test that reproduces the bug first
   - If refactoring â†’ ensure all existing tests pass before refactoring

5. **Test quality**
   - Tests must be independent (no test dependencies)
   - Tests must be repeatable and deterministic
   - Use descriptive test names that explain the behavior
   - Follow AAA pattern: Arrange, Act, Assert

### Workflow Enforcement

**When implementing ANY feature or change:**

1. **Start with a failing test**
   ```java
   @Test
   void should_calculateTotal_when_itemsProvided() {
       // Arrange
       ShoppingCart cart = new ShoppingCart();
       cart.addItem(new Item("Product", 10.0));
       
       // Act
       double total = cart.calculateTotal();
       
       // Assert
       assertEquals(10.0, total);
   }
   ```

2. **Run the test** - it MUST fail (red)

3. **Write minimal implementation** to make it pass
   ```java
   public double calculateTotal() {
       return 10.0; // Minimal implementation
   }
   ```

4. **Run the test** - it MUST pass (green)

5. **Refactor** if needed, keeping tests green

### Examples

**âœ… CORRECT TDD Workflow:**
```java
// Step 1: Write failing test first
@Test
void should_throwException_when_negativeAmount() {
    assertThrows(IllegalArgumentException.class, 
        () -> account.withdraw(-100));
}

// Step 2: Run test - it fails (RED)
// Step 3: Write minimal implementation
public void withdraw(double amount) {
    if (amount < 0) {
        throw new IllegalArgumentException("Amount cannot be negative");
    }
}

// Step 4: Run test - it passes (GREEN)
// Step 5: Refactor if needed
```

**âŒ WRONG - Writing code before tests:**
```java
// âŒ BAD: Implementation written first
public void withdraw(double amount) {
    if (amount < 0) {
        throw new IllegalArgumentException("Amount cannot be negative");
    }
    // ... more code
}

// âŒ BAD: Test written after implementation
@Test
void testWithdraw() {
    // Test written after code already exists
}
```

### Testing Tools

- **JUnit 5** for unit and integration tests
- **Mockito** for mocking dependencies
- **Testcontainers** for database and external service tests
- **AssertJ** for fluent assertions (preferred over JUnit assertions)
- **Spring Boot Test** for integration testing

### Code Coverage

- Minimum 80% code coverage required
- Coverage is enforced in CI/CD pipeline
- Focus on meaningful tests, not just coverage numbers
- Domain logic must have 100% test coverage
